<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-04-28T19:45:12-04:00</updated><id>http://localhost:4000/</id><title type="html">Rico Sharp</title><subtitle></subtitle><author><name>Rico Sharp</name><email>rico.sharp@gmail.com</email></author><entry><title type="html">Over the Air TV to IPTV on Raspberry Pi</title><link href="http://localhost:4000/posts/2019/Over-the-Air-to-IPTV-on-Raspberry-Pi" rel="alternate" type="text/html" title="Over the Air TV to IPTV on Raspberry Pi" /><published>2019-04-28T00:00:00-04:00</published><updated>2019-04-28T00:00:00-04:00</updated><id>http://localhost:4000/posts/2019/Over-the-Air-to-IPTV-on-Raspberry-Pi</id><content type="html" xml:base="http://localhost:4000/posts/2019/Over-the-Air-to-IPTV-on-Raspberry-Pi">&lt;p&gt;IPTV is an alternative transport method of broadcasting content, rather than traditional means. Instead of than using coaxial cabling, CAT 5/6 or WiFi might be used instead.&lt;/p&gt;

&lt;p&gt;There are three things to consider when implementing IPTV:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The source&lt;/li&gt;
  &lt;li&gt;The network&lt;/li&gt;
  &lt;li&gt;The client&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The source coming in can be anything -  a coaxial connection from your cable provider or an antenna. It could even be an http(s) stream, YouTube video, or even the HDMI output of an external device. These sources would be connected to a distribution device on one side. The other side of this distribution device will be the network.&lt;/p&gt;

&lt;p&gt;You can use unicast addressing to send IPTV over the network. However, unicast traffic is one to one and therefore not scalable in this situation. If five clients are watching the same channel, the same traffic is going over the network five times!&lt;/p&gt;

&lt;p&gt;Multicast is a more efficient means of sending this type of data over a network. It can be used to send a single stream of data to multiple clients. If the five clients are watching the same channel, then the source device is only sending the channel once to those five clients.&lt;/p&gt;

&lt;p&gt;A multitude of devices can be used to tune into an IPTV channel. This could be something as simple as VLC player to a full set top box solution managed by some type of middleware platform.&lt;/p&gt;

&lt;h2 id=&quot;equipment&quot;&gt;Equipment&lt;/h2&gt;
&lt;p&gt;I’m going to keep things simple and use the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Raspberry Pi 3 Model B+&lt;/li&gt;
  &lt;li&gt;Hauppauge WinTV-dualHD USB Tuner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The distribution device is the Pi. The source is free to air television which I am using a USB TV tuner to access. The Pi’s network port will be connected to my multicast VLAN. I will be accessing these streams from my Macbook Pro using VLC player.&lt;/p&gt;

&lt;p&gt;Digital TV transmits more than one channel on a given frequency. So if there are four channels on one frequency and three on the other, you can send out a total of seven channels to your network. I chose this particular USB TV Tuner because it can pick up two frequencies. One of these is not enough to tune into all the channels in my area but it is a good way to start learning about IPTV.&lt;/p&gt;

&lt;p&gt;Also, when choosing a tuner, make sure that it is compliant with the standard in your country. Here in the US the standard is ATSC, so the Hauappage USB that I chose supports this. Other countries might use DVD-T, so bare this in mind.&lt;/p&gt;

&lt;h2 id=&quot;write-raspbian-to-sd-card&quot;&gt;Write Raspbian to SD card&lt;/h2&gt;
&lt;p&gt;First let’s put an OS on the Pi. Connect your micro SD card to your computer and identify which disk it is. I’m using a MacBook Pro and the diskutil program.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;diskutil list&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You should be able to identify your micro SD card from the output. In my case, this is /dev/disk2.&lt;/p&gt;

&lt;p&gt;Next, unmount the disk and write the OS to it. I’m using the current April 2019 Raspbian Stretch Lite with kernel version 4.14. After image has been written to disk, unmount it again and insert the micro SD card into the Pi.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;diskutil unmountdisk /dev/disk2
~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;dd &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2019-04-08-raspbian-stretch-lite.img &lt;span class=&quot;nv&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/dev/disk2
~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;diskutil unmountdisk /dev/disk2&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;run-updates-and-upgrade-kernel&quot;&gt;Run updates and upgrade kernel&lt;/h2&gt;
&lt;p&gt;Start the Pi and update the system. While we’re at it, let’s enable SSH and reboot to verify it has started.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# update system&lt;/span&gt;
~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt update &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt;
~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt upgrade &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# enable SSH&lt;/span&gt;
~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;ssh
~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl start ssh
~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;reboot&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At the time of writing, Raspbian Stretch kernel is 4.14. This kernel only supports one of the tuners inside the Hauppauge WinTV-dualHD USB TV tuner out of the box. Kernel version 4.17 added support for both (see &lt;a href=&quot;https://www.linuxtv.org/wiki/index.php/ATSC_USB_devices&quot;&gt;here&lt;/a&gt;). You can update the Pi to 4.19 by issuing the below commands.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# update kernel&lt;/span&gt;
~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;rpi-update
~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;reboot&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;After rebooting, you should see that both tuners are detected.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; /dev/dvb
adapter0  adapter1&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;install-and-configure-iptv&quot;&gt;Install and Configure IPTV&lt;/h2&gt;
&lt;p&gt;Next, install the tools that we need to scan for channels and provide IPTV over the network.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# install IPTV tools&lt;/span&gt;
~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt install dvb-apps dvblast &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can use the scan program included with dvb-apps to scan for free to air channels in your area. A file containing the frequencies to scan is required. The easiest way to perform the scan is to use a file from /usr/share/dvb/dvb-legacy/atsc (assuming you are in an ATSC country) containing predefined frequencies. I will use the us-ATSC-center-frequencies-8VSB file to perform the scan, then output the results to a channels.conf file.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;scan /usr/share/dvb/dvb-legacy/atsc/us-ATSC-center-frequencies-8VSB &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; channels.conf&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This scan will take a while and will come up with a number of “tuning failed” results. This just means that there is nothing broadcasted on this frequency.&lt;/p&gt;

&lt;p&gt;You can build your own scan file to reduce the amount of time a scan takes. The &lt;a href=&quot;https://antennaweb.org/Address&quot;&gt;AntennaWeb&lt;/a&gt; site is useful when doing this (US only).&lt;/p&gt;

&lt;p&gt;The final channels.conf file will look something like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;channels.conf
WJLA-HD:177028615:8VSB:49:52:3
WJLACHG:177028615:8VSB:65:68:4
WJLACMT:177028615:8VSB:113:116:5
WJLATBD:177028615:8VSB:129:132:6
WUSA-HD:189028615:8VSB:49:52:1
LATV:189028615:8VSB:65:68:2
Justice:189028615:8VSB:81:84:3
WHUT HD:587028615:8VSB:49:52:1
WHUTKid:587028615:8VSB:65:68:2
ION:593028615:8VSB:49:52:3
qubo:593028615:8VSB:65:68:4
IONLife:593028615:8VSB:81:84:5
Shop:593028615:8VSB:97:100:6
HSN:593028615:8VSB:113:116:7
QVC:593028615:8VSB:129:132:8
WTTG-DT:605028615:8VSB:49:52:3
WDCA 20.1:605028615:8VSB:65:68:4
BUZZR 5.2:605028615:8VSB:81:84:5
ME TV 5.3:605028615:8VSB:97:100:6
MOVIES 20.2:605028615:8VSB:113:116:7
HEROES AND ICONS:605028615:8VSB:129:132:8
WRC-HD NBC 4 Washington:677028615:8VSB:49:52:3
COZI TV on WRC-TV:677028615:8VSB:65:68:4
WZDC   :677028615:8VSB:81:84:5
XITOS  :677028615:8VSB:97:100:6&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The channels.conf file can be opened with VLC player to start watching television. However, our goal is to  multicast these channels over a network.&lt;/p&gt;

&lt;p&gt;If you look closely at the channels.conf file, you will see that there are a bunch of different values. The first is the channel name, followed by the frequency, modulation, video PID, audio PID, and SID. You will notice that certain channels have the same frequency. If we pick the 177028615 frequency as an example, we can see four channels. Looking further down at 677028615 we can also see another four channels. Remember that Hauppauge TV tuner has two adapters? This means that one adapter can be configured to sit on the 177028615 frequency and the other on 677028615. The end result all eight channels can be transmitted to the multicast network.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.videolan.org/projects/dvblast.html&quot;&gt;DVBlast&lt;/a&gt; will be used to multicast the channels. We need to setup a &lt;a href=&quot;https://github.com/gfto/dvblast/blob/master/README&quot;&gt;config file&lt;/a&gt; containing the multicast groups. To transmit the eight channels on 177028615 and 677028615, two separate config files need to be created:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vi tuner0.conf
&lt;span class=&quot;c&quot;&gt;# Tuner 1 - Frequency 177028615&lt;/span&gt;
239.255.0.1:10000   1   3
239.255.0.2:10000   1   4
239.255.0.3:10000   1   5
239.255.0.4:10000   1   6&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vi tuner1.conf
&lt;span class=&quot;c&quot;&gt;# Tuner 2 - Frequency 677028615&lt;/span&gt;
239.255.0.5:10000   1   3
239.255.0.6:10000   1   4
239.255.0.7:10000   1   5
239.255.0.8:10000   1   6&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Run dvblast to multicast the channels out on the network&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;dvblast &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; 0 &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; 177028615 &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; tuner0.conf &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; VSB_8  &amp;amp;
~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;dvblast &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; 1 &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; 677028615 &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; tuner1.conf &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; VSB_8 &amp;amp;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;On another computer, run VLC Player and enter open one of the streams. On my Macbook Pro I do this through File &amp;gt; Open Network, then enter one of the streams (e.g. rtp://239.255.0.1:10000)&lt;/p&gt;

&lt;p&gt;You can use something like minisapserver to broadcast the channels to VLC Player using SAP so you don’t need to add enter the multicast addresses each time. I’ll write about this at a later time.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;p&gt;The videos and webpages below were essential references when getting this up and running:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=KI0LuIcFM98&quot;&gt;CWNE88 Youtube - Raspberry Pi Multicast TV server&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.linuxtv.org/wiki/index.php/Hauppauge_WinTV-dualHD&quot;&gt;Linux TV - Hauppauge WinTV dual HD&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/gfto/dvblast/blob/master/README&quot;&gt;DVBlast Config File&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Rico Sharp</name><email>rico.sharp@gmail.com</email></author><summary type="html">How to stream free to air television over an IP network</summary></entry><entry><title type="html">Migrating a UniFi access point to a new controller</title><link href="http://localhost:4000/posts/2018/Migrating-a-UniFi-access-point-to-a-new-controller" rel="alternate" type="text/html" title="Migrating a UniFi access point to a new controller" /><published>2018-05-13T00:00:00-04:00</published><updated>2018-05-13T00:00:00-04:00</updated><id>http://localhost:4000/posts/2018/Migrating-a-UniFi-access-point-to-a-new-controller</id><content type="html" xml:base="http://localhost:4000/posts/2018/Migrating-a-UniFi-access-point-to-a-new-controller">&lt;p&gt;If you have an access point that is already tied to an existing UniFi controller, you can migrate it to a new one without having to physically touch the device.&lt;/p&gt;

&lt;p&gt;I needed to do this in the past to move a bunch of access points from a failing &lt;a href=&quot;https://www.ubnt.com/unifi/unifi-cloud-key/&quot;&gt;Cloud Key&lt;/a&gt;, and onto a new controller running on a virtual machine.&lt;/p&gt;

&lt;p&gt;You will need the following:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;IP address of the access point.&lt;/li&gt;
  &lt;li&gt;Superadmin login of the previous controller.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SSH to the access point. Here you will need to use the superadmin login of the previous controller. Next, note down the MAC address by doing an ifconfig. Then finally, reset the access point to its factory defaults.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ssh ip-or-hostname-of-access-point
~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ifconfig
~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;syswrapper.sh restore-default&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The access point can take about a minute to reset. Ping it until you receive a reply, so you know when it is ready to be adopted by the new controller.&lt;/p&gt;

&lt;p&gt;Now tell the access point to talk to the new controller by invoking the set-inform command.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ssh ip-or-hostname-of-access-point
~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;set-inform http://ip-address-or-hostname-of-new-controller:8080/inform&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Open a browser and go to &lt;em&gt;http://ip-address-or-hostname-of-new-controller:8080&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Login, go to Devices, then click Adopt on the access point.&lt;/p&gt;

&lt;p&gt;The access point will now be managed by the new controller.&lt;/p&gt;

&lt;h2 id=&quot;notes&quot;&gt;Notes&lt;/h2&gt;

&lt;p&gt;The last time I did this, the access points did not adopt straight away. They would go through the process of adopting, then after five minutes, the status would still say adopting. In this case I had to run the set-inform command again on the access point, then I had the option to adopt again on the controller. The second time around seemed to work.&lt;/p&gt;

&lt;p&gt;You can view the logs on the access point with the following commands:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;tail /var/log/messages
OR
~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;less /var/log/messages&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you do not have a static IP reservation in DHCP, then the &lt;a href=&quot;https://chrome.google.com/webstore/detail/ubiquiti-device-discovery/hmpigflbjeapnknladcfphgkemopofig?hl=en&quot;&gt;Ubiquiti Device Discover Tool&lt;/a&gt; for Chrome is quite useful for finding the device. You must be on the same LAN as the access point to use this. Run a scan and find the IP address that corresponds to the MAC address from the ifconfig before. You can even use this tool to run the set-inform.&lt;/p&gt;</content><author><name>Rico Sharp</name><email>rico.sharp@gmail.com</email></author><summary type="html">How to migrate an existing access point to a new UniFi controller.</summary></entry><entry><title type="html">ScreenCloud Player on a Raspberry Pi</title><link href="http://localhost:4000/posts/2018/ScreenCloud-Player-on-a-Raspberry-Pi" rel="alternate" type="text/html" title="ScreenCloud Player on a Raspberry Pi" /><published>2018-05-12T00:00:00-04:00</published><updated>2018-05-12T00:00:00-04:00</updated><id>http://localhost:4000/posts/2018/ScreenCloud-Player-on-a-Raspberry-Pi</id><content type="html" xml:base="http://localhost:4000/posts/2018/ScreenCloud-Player-on-a-Raspberry-Pi">&lt;p&gt;&lt;a href=&quot;https://screen.cloud&quot;&gt;ScreenCloud&lt;/a&gt; is a digital signage solution that is very user friendly. It is simple to configure, and compatible with variety of TV’s and devices.&lt;/p&gt;

&lt;p&gt;This guide will go through the process of installing ScreenCloud Player on a Raspberry Pi, and configuring it to automatically start on boot.&lt;/p&gt;

&lt;h2 id=&quot;configuration&quot;&gt;Configuration&lt;/h2&gt;

&lt;p&gt;On a newly installed Raspbian system, download and install all updates, then reboot.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt update &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt;
~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt upgrade &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt;
~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;reboot&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Open Chromium and install the &lt;a href=&quot;https://chrome.google.com/webstore/detail/screencloud-digital-signa/efdahhfldoeikfglgolhibmdidbnpneo?hl=en&quot;&gt;ScreenCloud Digital Signage Player&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/posts/2018/sc-add-to-chrome.png&quot; alt=&quot;Add to Chrome&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note the app-id in the URL is efdahhfldoeikfglgolhibmdidbnpneo. We will need this later when configuring the application to automatically start on boot.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The application will automatically open once it is added to Chromium. Exit full screen by pressing escape on the keyboard and close the application.&lt;/p&gt;

&lt;p&gt;Configure Chromium to automatically start the ScreenCloud Player by editing the autostart file. Also, now is a good time to disable the screensaver.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nano /home/pi/.config/lxsession/LXDE-pi/autostart

&lt;span class=&quot;c&quot;&gt;# Add this line:&lt;/span&gt;
@chromium &lt;span class=&quot;nt&quot;&gt;--app-id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;efdahhfldoeikfglgolhibmdidbnpneo &lt;span class=&quot;nt&quot;&gt;--disable-session-crashed-bubble&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Comment out this line&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#@xscreensaver -no-splash&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Reboot the system. The pi will automatically login and start the ScreenCloud Player.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;reboot&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;notes&quot;&gt;Notes&lt;/h2&gt;

&lt;p&gt;The default username and password is raspberry/pi, which is assumed to be in use for this guide.&lt;/p&gt;

&lt;p&gt;If you need to install Chromium, run the following command:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt install chromium &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt;
OR
~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt install chromium-browser &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If the pi is not set to automatically login do the following:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;~]&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;raspi-config
3 Boot Options &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; B1 Desktop / CLI &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; B4 Desktop Autologin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;An alternative to finding the app-id is to navigate to chrome://apps in Chromium. Right click on ScreenCloud and create a shortcut on the desktop. Right click on the desktop shortcut and select properties. The app-id will be in the file path.&lt;/p&gt;</content><author><name>Rico Sharp</name><email>rico.sharp@gmail.com</email></author><summary type="html">Installing ScreenCloud Player on a Raspberry Pi, and configuring it to automatically start on boot.</summary></entry><entry><title type="html">My First Jekyll Post</title><link href="http://localhost:4000/posts/2018/My-First-Jekyll-Post" rel="alternate" type="text/html" title="My First Jekyll Post" /><published>2018-05-06T00:00:00-04:00</published><updated>2018-05-06T00:00:00-04:00</updated><id>http://localhost:4000/posts/2018/My-First-Jekyll-Post</id><content type="html" xml:base="http://localhost:4000/posts/2018/My-First-Jekyll-Post">&lt;p&gt;Hello World!&lt;/p&gt;</content><author><name>Rico Sharp</name><email>rico.sharp@gmail.com</email></author><summary type="html">Hello World!</summary></entry></feed>